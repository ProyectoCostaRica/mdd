(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mdd = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const Tokenizer = require('./tokenizer.js');
const { block } = require('./rules.js');

/**
 * Block Lexer
 */
module.exports = class Lexer {
  
  constructor(options) {
    this.tokens = [];
    this.tokenizer = new Tokenizer();
  }

  /**
   * Static Lex Method
   */
  static lex(src) {
    const lexer = new Lexer();
    return lexer.lex(src);
  }


  /**
   * Preprocessing
   */
  lex(src) {
    this.createTokens(src, this.tokens);
    return this.tokens;
  }

  /**
   * Lexing
   */
  createTokens(src, tokens = []) {

    let token;

    while (src) {

      // document
      if (token = this.tokenizer.document(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(src);
        tokens.push(token);
        break;
      }

      // metadata
      if (token = this.tokenizer.metadata(src)) {
        src = src.replace(token.raw,'');
        token.tokens1 = Lexer.lex(token.raw.replace(/\/\/ /g,'/ '));
        token.tokens2 = Lexer.lex(src);
        tokens.push(token);
        break;
      }

      // title
      if (token = this.tokenizer.title(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // CSS
      if (token = this.tokenizer.css(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // META
      if (token = this.tokenizer.meta(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_LINK_SAMETAB
      if (token = this.tokenizer.image_link_sametab(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }


      // IMAGE_LINK
      if (token = this.tokenizer.image_link(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_CAPTION
      if (token = this.tokenizer.image_caption(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_NO_CAPTION
      if (token = this.tokenizer.image_no_caption(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_COVER
      if (token = this.tokenizer.image_cover(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // AUDIO
      if (token = this.tokenizer.audio(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // LITERATURE
      if (token = this.tokenizer.literature(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // DETAILS
      if (token = this.tokenizer.details(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // FOOTER
      if (token = this.tokenizer.footer(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // HEADER
      if (token = this.tokenizer.header(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // HEADING
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // POEM
      if (token = this.tokenizer.poem(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // BLOCKQUOTE
      if (token = this.tokenizer.blockquote(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // COMMENT
      if (token = this.tokenizer.comment(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // LIST1
      if (token = this.tokenizer.list1(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

       // LIST1_ITEM
      if (token = this.tokenizer.list1_item(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // NOTE
      if (token = this.tokenizer.note(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // MARKER
      if (token = this.tokenizer.marker(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }


      // PARAGRAPH
      if (token = this.tokenizer.paragraph(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // LINE BREAK
      if (token = this.tokenizer.line_break(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }
      
      // LINK_SAMETAB
      if (token = this.tokenizer.link_sametab(src)) {
        src = src.replace(token.raw,'');
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }


      // LINK
      if (token = this.tokenizer.link(src)) {
        src = src.replace(token.raw,'');
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // REF
      if (token = this.tokenizer.ref(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // BOLD_ITALIC
      if (token = this.tokenizer.bold_italic(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // BOLD
      if (token = this.tokenizer.bold(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // ITALIC
      if (token = this.tokenizer.italic(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // STRIKETHROUGH

      if (token = this.tokenizer.strikethrough(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }


      // TEXT
      if (token = this.tokenizer.text(src)) {
        tokens.push(token);
        break;
      }

      if(true){
        console.log("Sin match")
      }

    }

    return tokens;
  }

 


};

},{"./rules.js":5,"./tokenizer.js":6}],2:[function(require,module,exports){
const Lexer = require('./lexer.js');
const ParserHTML = require('./parser_html.js');
const ParserLATEX = require('./parser_latex.js');
const { block } = require('./rules.js');


function mdd(src, format) {
  
  var tokens;
  
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }


  // Realiza la operaciÃ³n
  try {

    tokens = Lexer.lex(src);
    console.log(tokens);

    if(format=="latex"){
      const out = ParserLATEX.parse(tokens);
      return out;
    }

    else{
      var out = ParserHTML.parse(tokens);
      var author='author'
      var year='year'
      var title='title'
      var description='description'

      if(block.html_author.exec(out)){
        author = block.html_author.exec(out)[1];
      }

      if (block.html_year.exec(out)){
        year= block.html_year.exec(out)[1]
      }

      if (block.html_title.exec(out)){
        title = block.html_title.exec(out)[1]
      }

      if (block.html_description.exec(out)){
        description= block.html_description.exec(out)[1];
      }

      out = out.replace('$$AUTHOR_MINDDO$$', author).replace('$$YEAR_MINDDO$$', year).replace('$$DESCRIPTION_MINDDO$$', description).replace('$$TITLE_MINDDO$$', title);
      out = out.replace(/\+ /gm, '&nbsp ');
      console.log(out)
      return out;
    }
  
  } catch (e) {
    e.message += '\nHay un error en el sistema';
    throw e;
  }
}

module.exports = {transform: mdd};
},{"./lexer.js":1,"./parser_html.js":3,"./parser_latex.js":4,"./rules.js":5}],3:[function(require,module,exports){
  
/**
 * Parsing & Compiling
 */
module.exports = class ParserHTML {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static parse(tokens) {
    const parser = new ParserHTML();
    return parser.parse(tokens);
  }


  /**
   * Parse Loop
   */
  parse(tokens) {
    //console.log(tokens)
    let out = '';
    let i, token, txt;
    const l = tokens.length;

    for (i = 0; i < l; i++) {
      token = tokens[i];

      switch (token.type) {

        case 'document': {
          const interior= ParserHTML.parse(token.tokens)
          txt='<!DOCTYPE html>\n<html lang="'+token.language+'">\n'+interior+ '\n\n</html>'
          out += txt;
          continue;
        }

        case 'metadata': {
          const interiorMeta= ParserHTML.parse(token.tokens1)
          const interiorBody= ParserHTML.parse(token.tokens2)
          txt='\n<head>\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n'+interiorMeta+ '</head>\n\n<body>\n'+interiorBody+'\n</body>'
          out += txt;
          continue;
        }

        case 'title': {
          txt='  <title>'+ token.text + '</title>\n';
          out += txt;
          continue;
        }

        case 'css': {
          txt='  <link rel="stylesheet"  href="'+ token.text + '">\n';
          out += txt;
          continue;
        }

        case 'meta': {
          txt='  <meta name="'+ token.name + '" content="'+token.content+'">\n';
          out += txt;
          continue;
        }

        case 'literature': {
          const interior= ParserHTML.parse(token.tokens)
          const header= "<div class='header'>\n<p class='title'>$$TITLE_MINDDO$$</p>\n<p class='author'>$$DESCRIPTION_MINDDO$$</p>\n</div>\n\n"
          txt='<div class="literature">\n\n'+header+interior+ '</div>\n\n';
          out += txt;
          continue;
        }


        case 'details': {
          //console.log(token)
          const interior= ParserHTML.parse(token.tokens);
          txt='<div class="details">\n<details>\n  <summary>'+token.title+'</summary>\n<div>\n'+interior+'</div>\n</details>\n</div>\n\n';
          out += txt;
          continue;
        }

        case 'footer': {
          //console.log(token)
          console.log("ENTRO")
          const interior= ParserHTML.parse(token.tokens);
          txt='<footer>\n'+interior+'</footer>';
          out += txt;
          continue;
        }

        case 'header': {
          //console.log(token)
          console.log("ENTRO")
          const interior= ParserHTML.parse(token.tokens);
          txt='<div class="topnav"><div>\n'+interior+'</div></div>';
          out += txt;
          continue;
        }
        
        case 'heading': {
          const interior= ParserHTML.parse(token.tokens)
          txt='  <h' + token.depth + '>' + interior + '</h' + token.depth + '>\n';
          out += txt;
          continue;
        }

        case 'audio': {
          txt='<div class="audio">\n<audio controls>\n<source src="'+token.link+'" alt="'+token.title+'"type="audio/mpeg">\n</audio>\n</div>';
          out += txt;
          continue;
        }

        case 'image_link_sametab': {
          txt='<a href="'+token.external+'"><img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img></a>\n';
          out += txt;
          continue;
        }

        case 'image_link': {
          txt='<a target="_blank" href="'+token.external+'"><img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img></a>\n';
          out += txt;
          continue;
        }

        case 'image_caption': {
          txt='<figure>\n<img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'">\n<figcaption>'+token.note+'</figcaption>\n</figure>\n';
          out += txt;
          continue;
        }

        case 'image_no_caption': {
          txt='<img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img>\n';
          out += txt;
          continue;
        }

        case 'image_cover': {
          continue;
        }


        case 'poem': {
          const interior=ParserHTML.parse(token.tokens);
          txt='  <div class="poem">\n<div>\n' +interior+'\n</div>\n</div>\n';
          out += txt;
          continue;
        }

        case 'blockquote': {
          const interior=ParserHTML.parse(token.tokens);
          txt='  <blockquote>\n<div>\n' +interior+'\n</div>\n</blockquote>\n';
          out += txt;
          continue;
        }

        case 'comment': {
          txt='<div class="comment"\n'+ token.text+'\n</div>';
          out += txt;
          continue;
        }


        case 'list1': {
          const interior=ParserHTML.parse(token.tokens);
          txt='  <ul>\n' +interior+'  </ul>\n';
          out += txt;
          continue;
        }

        case 'list1_item': {
          const interior=ParserHTML.parse(token.tokens);
          txt='  <li>' +interior+'  </li>\n';
          out += txt;
          continue;
        }

        case 'note': {
          const interior= ParserHTML.parse(token.tokens);
          txt='<p id="n'+token.id+'">'+token.id+". "+interior +'<a class="ref" href="#ref'+token.id+'">&#8617</a></p>\n';
          out += txt;
          continue;
        }

        case 'marker': {
          txt='<div class="marker">* * *</div>\n';
          out += txt;
          continue;
        }

        case 'paragraph': {
          const interior= ParserHTML.parse(token.tokens);
          txt='  <p>' +interior +'</p>\n';
          out += txt;
          continue;
        }

        case 'line_break': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<br>'+next;
          out += txt;
          continue;
        }

        case 'bold': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b>'+text+'</b>'+next;
          out += txt;
          continue;
        }

        case 'link_sametab': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a href="'+token.link+'">'+token.title+'</a>'+next;
          out += txt;
          continue;
        }

        case 'link': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a href="'+token.link+'" target="_blank">'+token.title+'</a>'+next;
          out += txt;
          continue;
        }


        case 'ref': {
          console.log("ENTRO")
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a class="ref" href="#n'+token.id+'" id="ref'+token.id+'">'+text+'<sup>'+token.id+'</sup></a>'+next;
          out += txt;
          continue;
        }


        case 'bold_italic': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b><i>'+text+'</i></b>'+next;
          out += txt;
          continue;
        }

        case 'bold': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b>'+text+'</b>'+next;
          out += txt;
          continue;
        }

        case 'italic': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<i>'+text+'</i>'+next;
          out += txt;
          continue;
        }

        case 'strikethrough': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<del>'+text+'</del>'+next;
          out += txt;
          continue;
        }

        case 'text': {
          out += token.text;
          continue;
        }
        


      }
    }

    return out;
  }


};

},{}],4:[function(require,module,exports){
  
/**
 * Parsing & Compiling
 */
module.exports = class ParserLATEX {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static parse(tokens) {
    const parser = new ParserLATEX();
    return parser.parse(tokens);
  }


  /**
   * Parse Loop
   */
  parse(tokens) {
    let out = '';
    let i, token, txt, sect,size;
    const l = tokens.length;

    for (i = 0; i < l; i++) {
      token = tokens[i];

      switch (token.type) {

        case 'document': {
          const interior= ParserLATEX.parse(token.tokens)
          txt='\\begin{document}\n\n'+interior+'\\end{document}'
          out += txt;
          continue;
        }

        case 'metadata': {
          const interiorBody= ParserLATEX.parse(token.tokens2)
          txt=interiorBody
          out += txt;
          continue;
        }

        case 'literature': {
          const interior= ParserLATEX.parse(token.tokens)
          txt=interior;
          out += txt;
          continue;
        }

        case 'details': {
          // \chapter{Let's begin}
          const interior= ParserLATEX.parse(token.tokens);
          txt='\\section*{'+token.title+'}\n\n'+interior;
          out += txt;
          continue;
        }

        
        case 'heading': {
          if(token.depth==1) {sect= "\\section*{"}
          if(token.depth==2) {sect= "\\subsection*{"}
          if(token.depth>=3) {sect= "\\subsubsection*{"}
          txt=sect + token.text + '}\n\n';
          out += txt;
          continue;
        }

        case 'image_caption': {

          if(token.width.slice(token.width.length - 1)=="%"){
            size= parseInt(token.width)/100+"\\textwidth";
          }

          else{
            size=token.width;
          }
          
          txt= "\\begin{figure}[htb]\n \\centering \n \\includegraphics[width="+size+"]{"+token.link+"}\n \\caption{"+token.note+"}\n\\end{figure}\n\n"
          out += txt;
          continue;
        }

        case 'image_no_caption': {
          continue;
        }

        case 'image_cover': {
          txt="\\includepdf{"+token.link+"}\n\n";
          out += txt;
          continue;
        }

        case 'poem': {
          const interior= ParserLATEX.parse(token.tokens);
          txt=interior;
          out += txt;
          continue;
        }
        

        case 'note': {
          const interior= ParserLATEX.parse(token.tokens);
          txt=interior;
          out += txt;
          continue;
        }

        case 'paragraph': {
          const interior= ParserLATEX.parse(token.tokens);
          txt='\\par '+ interior+ '\n\n';
          out += txt;
          continue;
        }

        case 'link': {
          continue;
        }


        case 'ref': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+text+next;
          out += txt;
          continue;
        }


        case 'bold_italic': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textbf{\\textit{'+text+'}}'+next;
          out += txt;
          continue;
        }

        case 'bold': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textbf{'+text+'}'+next;
          out += txt;
          continue;
        }

        case 'italic': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textit{'+text+'}'+next;
          out += txt;
          continue;
        }

        case 'text': {
          out += token.text;
          continue;
        }

        continue;
        


      }
    }

    return out;
  }


};

},{}],5:[function(require,module,exports){

/**
 * Block-Level Grammar
 */
const block = {

  document: /\/\/ LANGUAGE:\s*(\S*)\s*/,
  metadata: /(\/\/ [^\n]*(?:\s|$)*)+/,
  title: /\/ TITLE:\s*([^\n]*)(?<!\s)\s*/,
  css: /\/ CSS:\s*([^\n]*)(?<!\s)\s*/,
  meta: /\/ ([^\n]*):\s*([^\n]*)(?<!\s)\s*/,
  image_link_sametab: /^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\((.*?)\){sametab}\s*/,
  image_link: /^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\((.*?)\)\s*/,
  image_caption:/^\s*!\[(.*?)]\((.*?)\)\((.*?)\) *\n\*(.*)\*\s*/,
  image_no_caption:/^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\s*/,
  image_cover:/^\s*!\[(.*?)]\s*/,
  audio:/^\s*!!\[(.*?)]\((.*?)\)\s*/,
  literature: /^\s*---+\s*TEXT\s*-*\s*((.|\s)*?)---+\s*/,
  details: /^\s*---+\s*DETAIL\s*---+\s# (.*)\s*((.|\s)*?\n)-+\s*/,
  footer: /^\s*---+\s*FOOTER\s*---+\s*((.|\s)*?\n)-+\s*/,
  header: /^\s*---+\s*HEADER\s*---+\s*((.|\s)*?\n)-+\s*/,
  heading: /^\s*(#{1,6}) +([^\n]*)(?<!\s)\s*/,
  poem:/^\s*(>>>[^\n]*(?:\n|$))+\s*/,
  blockquote:/^\s*(>[^\n]*(?:\n|$))+\s*/,
  comment:/^\s*```((?:\s|.)*?)```\s*/,
  list1:/^\s*(-- [^\n]*(?:\n|$))+\s*/,
  list1_item:/^\s*- ([^\n]*)(?<!\s)\s*(?:\n|$)+\s*/,
  note:/^\s*\[\^(.*?)\]: (.*)\s*/,
  marker: /^\s*\* \* \*\s*/,
  paragraph:/^([\S\s]+?)\n\n+/,
  line_break:/(.*)\n(.*)/,
  link_sametab:/(.*)\[(.*?)]\((.*?)\){sametab}(.*)/,
  link:/(.*)\[(.*?)]\((.*?)\)(.*)/,
  ref: /^(.*)\<(.*?)\[\^(.*?)\]\>(.*)/,
  bold_italic: /(.*)\*\*\*(.*?)\*\*\*(.*)/,
  bold: /(.*)\*\*(.*?)\*\*(.*)/,
  italic: /(.*)\*(.*?)\*(.*)/,
  strikethrough: /(.*)\~\~(.*?)\~\~(.*)/,
  html_author: /<meta name="AUTHOR" content="(.*)"\>\s/,
  html_year: /<meta name="YEAR" content="(.*)"\>\s/,
  html_description: /<meta name="DESCRIPTION" content="(.*)"\>\s/,
  html_title: /<title>(.*)<\/title\>/,

};


module.exports = {
  block,
};

},{}],6:[function(require,module,exports){
const { block } = require('./rules.js');

/**
 * Tokenizer
 */
module.exports = class Tokenizer {

  constructor() {
    this.rules=block;
  }


  document(src) {
    const cap = this.rules.document.exec(src);
    if (cap) {
      return {
        type: 'document',
        raw: cap[0],
        language: cap[1]
      };
    }
  }

  metadata(src) {
    const cap = this.rules.metadata.exec(src);
    if (cap) {
      return {
        type: 'metadata',
        raw: cap[0]
      };
    }
  }

  title(src) {
    const cap = this.rules.title.exec(src);
    if (cap) {
      return {
        type: 'title',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  css(src) {
    const cap = this.rules.css.exec(src);
    if (cap) {
      return {
        type: 'css',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  meta(src) {
    const cap = this.rules.meta.exec(src);
    if (cap) {
      return {
        type: 'meta',
        raw: cap[0],
        name: cap[1],
        content: cap[2],
      };
    }
  }

  literature(src) {
    const cap = this.rules.literature.exec(src);
    if (cap) {
      return {
        type: 'literature',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  details(src){
    const cap = this.rules.details.exec(src);
    if (cap) {
      return {
        type: 'details',
        raw: cap[0],
        title: cap[1],
        text: cap[2]
      };
    }
  }

  footer(src){
    const cap = this.rules.footer.exec(src);
    if (cap) {
      return {
        type: 'footer',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  header(src){
    const cap = this.rules.header.exec(src);
    if (cap) {
      return {
        type: 'header',
        raw: cap[0],
        text: cap[1]
      };
    }
  }


  heading(src) {
    const cap = this.rules.heading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text: cap[2]
      };
    }
  }

  audio(src) {
    const cap = this.rules.audio.exec(src);
    if (cap) {
      return {
        type: 'audio',
        raw: cap[0],
        title: cap[1],
        link: cap[2]
      };
    }
  }

  image_link_sametab(src) {
    const cap = this.rules.image_link_sametab.exec(src);
    if (cap) {
      return {
        type: 'image_link_sametab',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        external:cap[4]
      };
    }
  }

  image_link(src) {
    const cap = this.rules.image_link.exec(src);
    if (cap) {
      return {
        type: 'image_link',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        external:cap[4]
      };
    }
  }


  image_caption(src) {
    const cap = this.rules.image_caption.exec(src);
    if (cap) {
      return {
        type: 'image_caption',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        note:cap[4]
      };
    }
  }

  image_no_caption(src) {
    const cap = this.rules.image_no_caption.exec(src);
    if (cap) {
      return {
        type: 'image_no_caption',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3]
      };
    }
  }

  image_cover(src) {
    const cap = this.rules.image_cover.exec(src);
    if (cap) {
      return {
        type: 'image_cover',
        raw: cap[0],
        link:cap[1]
      };
    }
  }

  poem(src) {
    const cap = this.rules.poem.exec(src);
    if (cap) {
      const text3= cap[0].replace(/\n+/gm, "<br>");
      const text2 = text3.replace(/>>> /gm, '');
      const text1 = text2.replace(/>>>/gm, '');
      const text = text1.replace(/<br>$/gm, '');

      return {
        type: 'poem',
        raw: cap[0],
        text
      };
    }
  }

  blockquote(src) {
    const cap = this.rules.blockquote.exec(src);
    if (cap) {
      const text3= cap[0].replace(/> /gm, '');
      const text2 = text3.replace(/>/gm, '');
      const text1 = text2.replace(/\n+/gm, "<br><br>");
      const text = text1.replace(/<br>$/gm, '');

      return {
        type: 'blockquote',
        raw: cap[0],
        text
      };
    }
  }

  comment(src) {
    const cap = this.rules.comment.exec(src);
    if (cap) {
      const text= cap[1].replace(/\</gm, "&lt;").replace(/\n/gm, "<br>").replace(/ /gm, "&nbsp;");;

      return {
        type: 'comment',
        raw: cap[0],
        text
      };
    }
  }

  list1(src) {
    const cap = this.rules.list1.exec(src);
    if (cap) {
      const text = cap[0].replace(/-- /gm, '- ');

      return {
        type: 'list1',
        raw: cap[0],
        text
      };
    }
  }

  list1_item(src) {
    const cap = this.rules.list1_item.exec(src);
    if (cap) {

      return {
        type: 'list1_item',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  note(src) {
    const cap = this.rules.note.exec(src);
    if (cap) {
      return {
        type: 'note',
        raw: cap[0],
        id: cap[1],
        text: cap[2]
      };
    }
  }

  marker(src) {
    const cap = this.rules.marker.exec(src);
    if (cap) {
      return {
        type: 'marker',
        raw: cap[0]
      };
    }
  }



  paragraph(src) {
    const cap = this.rules.paragraph.exec(src);
    if (cap) {
      console.log('Parrafo');
      console.log(cap);
      return {
        type: 'paragraph',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  line_break(src) {
    const cap = this.rules.line_break.exec(src);
    if (cap) {
      console.log('Line break');
      console.log(cap);
      return {
        type: 'line_break',
        raw: cap[0],
        previous: cap[1],
        next: cap[2],
      };
    }
  }

  link_sametab(src) {
    const cap = this.rules.link_sametab.exec(src);
    if (cap) {

      if(cap[2]==''){
        cap[2]=cap[3];
      }

      return {
        type: 'link_sametab',
        raw: cap[0],
        previous: cap[1],
        title:cap[2],
        link:cap[3],
        next: cap[4],
      };
    }
  }

  link(src) {
    const cap = this.rules.link.exec(src);
    if (cap) {

      if(cap[2]==''){
        cap[2]=cap[3];
      }

      return {
        type: 'link',
        raw: cap[0],
        previous: cap[1],
        title:cap[2],
        link:cap[3],
        next: cap[4],
      };
    }
  }

  ref(src) {
    const cap = this.rules.ref.exec(src);
    if (cap) {
      console.log("PERRO")
      return {
        type: 'ref',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        id: cap[3],
        next: cap[4],
      };
    }
  }

  bold_italic(src) {
    const cap = this.rules.bold_italic.exec(src);
    if (cap) {
      return {
        type: 'bold_italic',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  bold(src) {
    const cap = this.rules.bold.exec(src);
    if (cap) {
      return {
        type: 'bold',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  italic(src) {
    const cap = this.rules.italic.exec(src);
    if (cap) {
      return {
        type: 'italic',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  strikethrough(src) {
    const cap = this.rules.strikethrough.exec(src);
    if (cap) {
      return {
        type: 'strikethrough',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  text(src) {
      return {
        type: 'text',
        raw: src,
        text: src
      };
  }


};

},{"./rules.js":5}]},{},[2])(2)
});
